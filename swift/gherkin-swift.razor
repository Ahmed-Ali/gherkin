@using Berp;
@helper CallProduction(ProductionRule production)
{
  switch(production.Type)
  {
    case ProductionRuleType.Start:
      @:  start_rule(context, :@production.RuleName);
      break;
    case ProductionRuleType.End:
      @:  end_rule(context, :@production.RuleName);
      break;
    case ProductionRuleType.Process:
      @:  build(context, token);
      break;
  }
}
@helper HandleParserError(IEnumerable<string> expectedTokens, State state)
{<text>
      state_comment = "State: @state.Id - @Raw(state.Comment)"
      token.detach
      expected_tokens = ["@Raw(string.Join("\", \"", expectedTokens))"]
      error = token.eof? ? UnexpectedEOFException.new(token, expected_tokens, state_comment) : UnexpectedTokenException.new(token, expected_tokens, state_comment)
      raise error if (stop_at_first_error)
      add_error(context, error)
      return @state.Id</text>}
@helper MatchToken(TokenType tokenType)
{<text>match_@(tokenType)(context, token)</text>}
// This file is generated. Do not edit! Edit gherkin-swift.razor instead.
import Errors

enum RuleType {
  case None
  @foreach(var rule in Model.RuleSet.Where(r => !r.TempRule))
  {<text>  case @rule.Name.Replace("#", "_") // @rule.ToString(true)
</text>}
}

enum InvalidOperationException: ErrorType {

    case UnknownState
}

class ParserContext {
    var tokenScanner: TokenScanner
    var tokenMatcher: TokenMatcher
    var tokenQueue: [String]
    var errors: [String]

    init(tokenScanner: TokenScanner, tokenMatcher: TokenMatcher, tokenQueue: [String], errors: [String]) {

        self.tokenScanner = tokenScanner
        self.tokenMatcher = tokenMatcher
        self.tokenQueue = tokenQueue
        self.errors = errors
    }
}

class @Model.ParserClassName {
  var stopAtFirstError: Bool = true
  var astBuilder: ASTBuilder

      init(astBuilder: ASTBuilder) {

        self.astBuilder = astBuilder
      }
}

class Parser {
  var stopAtFirstError: Bool = true
  var astBuilder: ASTBuilder

  init(astBuilder: ASTBuilder) {

      self.astBuilder = astBuilder
  }

  func parse(tokenScanner: TokenScanner, tokenMatcher: TokenMatcher) throws -> String {

      self.astBuilder.reset
      tokenMatcher.reset()

      var context = ParserContext(tokenScanner: tokenScanner, tokenMatcher: tokenMatcher, tokenQueue: [], errors: [])

      startRule(context, ruleType: .@Model.RuleSet.StartRule.Name)
      var state = 0
      var token: ParserContext?

      while !token.eof {

          token = readToken(context)
          if let newToken = token {
              do {
                  state = try matchToken(state, token: newToken, context: context)
              } catch {
                  //FIXME: Need to have some kind of logger
                  print ("failed")
              }
          }
      }

      endRule(context, ruleType: .@Model.RuleSet.StartRule.Name)

      if context.errors.count > 0 {

          throw CompositeParserException.new(context.errors)
      }

      return getResult()
  }

  func startRule(context: ParserContext, ruleType: RuleType) {
      handleASTError(context, action: {
          self.astBuilder.startRule(ruleType)
      })

  }

  func endRule(context: ParserContext, ruleType: RuleType) {
      handleASTError(context, action: {
          self.astBuilder.endRule(ruleType)
      })
  }

  func getResult() -> String {

      return self.astBuilder.getResult()
  }

  func readToken(context: ParserContext) -> ParserContext {

  }

  func matchToken(state: Int, token: ParserContext, context: ParserContext) throws -> Int {
    switch state {
      @foreach( var state in Model.States.Values.Where(s => !s.IsEndState))
      {
      @:case @state.Id:
          <text>return</text> @:matchTokenAt@(state.Id)(token, context: context)
      }
      default:
          throw InvalidOperationException.UnknownState
    }
  }
}

