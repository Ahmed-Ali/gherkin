// ------------------------------------------------------------------------------
//  <auto-generated>
//      This code was generated by Berp (http://https://github.com/gasparnagy/berp/).
// 
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </auto-generated>
// ------------------------------------------------------------------------------

@using Berp;
@helper CallProduction(ProductionRule production)
{
    switch(production.Type)
    {
        case ProductionRuleType.Start:
                @:StartRule(context, RuleType.@production.RuleName);
            break;
        case ProductionRuleType.End:
                @:EndRule(context, RuleType.@production.RuleName);
            break;
        case ProductionRuleType.Process:
                @:Build(context, token);
            break;
    }
}
@helper HandleParserError(IEnumerable<string> expectedTokens, State state)
{<text>
            const string stateComment = "State: @state.Id - @Raw(state.Comment)";
            token.Detach();
            var expectedTokens = new string[] {"@Raw(string.Join("\", \"", expectedTokens))"};
            var error = token.IsEOF ? (ParserException)new UnexpectedEOFException(token, expectedTokens, stateComment) 
                : new UnexpectedTokenException(token, expectedTokens, stateComment);
            if (StopAtFirstError)
                throw error;
            
            AddError(context, error);
            return @state.Id;
</text>}
@helper MatchToken(TokenType tokenType)
{<text>Match_@(tokenType)(context, token)</text>}

package gherkin;

import java.util.*;

    public class @Model.ParserClassName
    {
        public enum TokenType
        {
            None,
            @foreach(var rule in Model.RuleSet.TokenRules)
            {<text>        @rule.Name.Replace("#", ""),
    </text>}
        }

        public enum RuleType
        {
            None,
            @foreach(var rule in Model.RuleSet.Where(r => !r.TempRule))
            {<text>        @rule.Name.Replace("#", "_"), // @rule.ToString(true)
    </text>}
        }


        public boolean StopAtFirstError;

        class ParserContext
        {
            public final ITokenScanner TokenScanner;
            public final ITokenMatcher TokenMatcher;
            public final IAstBuilder Builder;
            public final Queue<Token> TokenQueue;
            public final List<ParserException> Errors;


            ParserContext(ITokenScanner tokenScanner, ITokenMatcher tokenMatcher, IAstBuilder builder, Queue<Token> tokenQueue, List<ParserException> errors) {
                TokenScanner = tokenScanner;
                TokenMatcher = tokenMatcher;
                Builder = builder;
                TokenQueue = tokenQueue;
                Errors = errors;
            }
        }

        public Object Parse(ITokenScanner tokenScanner)
        {
            return Parse(tokenScanner, new TokenMatcher(), new AstBuilder());
        }

        public Object Parse(ITokenScanner tokenScanner, ITokenMatcher tokenMatcher, IAstBuilder astBuilder)
        {
            ParserContext context = new ParserContext(
                tokenScanner,
                tokenMatcher,
                astBuilder,
                new LinkedList<Token>(),
                new ArrayList<ParserException>()
            );

            StartRule(context, RuleType.@Model.RuleSet.StartRule.Name);
            int state = 0;
            Token token;
            do
            {
                token = ReadToken(context);
                state = MatchToken(state, token, context);
            } while(!token.IsEOF);

            EndRule(context, RuleType.@Model.RuleSet.StartRule.Name);

            if (context.Errors.Count > 0)
            {
                throw new CompositeParserException(context.Errors.ToArray());
            }

            return GetResult(context);
        }

        private void AddError(ParserContext context, ParserException error)
        {
            context.Errors.Add(error);
            if (context.Errors.Count > 10)
                throw new CompositeParserException(context.Errors.ToArray());
        }

        private void HandleAstError(ParserContext context, Action action)
        {
            HandleExternalError(context, () => { action(); return true; });
        }

        private T HandleExternalError<T>(ParserContext context, Func<T> action, T defaultValue = default(T))
        {
            if (StopAtFirstError)
            {
                return action();
            }

            try
            {
                return action();
            }
            catch (CompositeParserException compositeParserException)
            {
                foreach (var error in compositeParserException.Errors)
                    AddError(context, error);
            }
            catch (ParserException error)
            {
                AddError(context, error);
            }
            return defaultValue;
        }

        void Build(ParserContext context, Token token)
        {
            HandleAstError(context, () => context.Builder.Build(token));
        }

        void StartRule(ParserContext context, RuleType ruleType)
        {
            HandleAstError(context, () => context.Builder.StartRule(ruleType));
        }

        void EndRule(ParserContext context, RuleType ruleType)
        {
            HandleAstError(context, () => context.Builder.EndRule(ruleType));
        }

        object GetResult(ParserContext context)
        {
            return context.Builder.GetResult();
        }

        Token ReadToken(ParserContext context)
        {
            return context.TokenQueue.Count > 0 ? context.TokenQueue.Dequeue() : context.TokenScanner.Read();
        }

        @foreach(var rule in Model.RuleSet.TokenRules)
        {<text>
        bool Match_@(rule.Name.Replace("#", ""))(ParserContext context, Token token)
        {
            @if (rule.Name != "#EOF")
            {
            @:if (token.IsEOF) return false;
            }
            return HandleExternalError(context, () => context.TokenMatcher.Match_@(rule.Name.Replace("#", ""))(token), false); 
        }</text>
        }

        int MatchToken(int state, Token token, ParserContext context)
        {
            int newState;
            switch(state)
            {
            @foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
            {
                @:case @state.Id:
                    @:newState = MatchTokenAt_@(state.Id)(token, context);
                    @:break;
            }
                default:
                    throw new InvalidOperationException("Unknown state: " + state);
            }
            return newState;
        }

    @foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
    {
        <text>
        // @Raw(state.Comment)
        int MatchTokenAt_@(state.Id)(Token token, ParserContext context)
        {
            @foreach(var transition in state.Transitions)
            {
            @:if (@MatchToken(transition.TokenType))
            @:{
                if (transition.LookAheadHint != null)
                {
                @:if (LookAhead_@(transition.LookAheadHint.Id)(context, token))
                @:{
                }
                foreach(var production in transition.Productions)
                {
                    @CallProduction(production)
                }
                @:return @transition.TargetState;
                if (transition.LookAheadHint != null)
                {
                @:}
                }
            @:}
            }
            @HandleParserError(state.Transitions.Select(t => "#" + t.TokenType.ToString()).Distinct(), state)
        }
        </text>
    }

    @foreach(var lookAheadHint in Model.RuleSet.LookAheadHints)
    {
        <text>
        bool LookAhead_@(lookAheadHint.Id)(ParserContext context, Token currentToken)
        {
            currentToken.Detach();
            Token token;
            var queue = new Queue<Token>();
            bool match = false;
            do
            {
                token = ReadToken(context);
                token.Detach();
                queue.Enqueue(token);

                if (false
                @foreach(var tokenType in lookAheadHint.ExpectedTokens)
                {
                    @:|| @MatchToken(tokenType)
                }
                )
                {
                    match = true;
                    break;
                }
            } while (false
            @foreach(var tokenType in lookAheadHint.Skip)
            {
                @:|| @MatchToken(tokenType)
            }
            );
            foreach(var t in queue)
                context.TokenQueue.Enqueue(t);
            return match;
        }
        </text>
    }
    }

    public partial interface IAstBuilder 
    {
        void Build(Token token);
        void StartRule(RuleType ruleType);
        void EndRule(RuleType ruleType);
        object GetResult();
    }

    public partial interface ITokenScanner 
    {
        Token Read();
    }

    public partial interface ITokenMatcher
    {
        @foreach(var rule in Model.RuleSet.TokenRules)
        {
        @:bool Match_@(rule.Name.Replace("#", ""))(Token token);
        }
    }

#pragma warning restore
#endregion
