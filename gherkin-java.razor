//      This code was generated by Berp (http://https://github.com/gasparnagy/berp/).
//
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.

@using Berp;
@helper CallProduction(ProductionRule production)
{
    switch(production.Type)
    {
        case ProductionRuleType.Start:
                @:StartRule(context, RuleType.@production.RuleName);
            break;
        case ProductionRuleType.End:
                @:EndRule(context, RuleType.@production.RuleName);
            break;
        case ProductionRuleType.Process:
                @:Build(context, token);
            break;
    }
}
@helper HandleParserError(IEnumerable<string> expectedTokens, State state)
{<text>
        final String stateComment = "State: @state.Id - @Raw(state.Comment)";
        token.Detach();
        List<String> expectedTokens = asList("@Raw(string.Join("\", \"", expectedTokens))");
        ParserException error = token.IsEOF()
                ? new ParserException.UnexpectedEOFException(token, expectedTokens, stateComment)
                : new ParserException.UnexpectedTokenException(token, expectedTokens, stateComment);
        if (StopAtFirstError)
            throw error;

        AddError(context, error);
        return @state.Id;
</text>}
@helper MatchToken(TokenType tokenType)
{<text>Match_@(tokenType)(context, token)</text>}

package gherkin;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

import static java.util.Arrays.asList;

    public class @Model.ParserClassName
    {
        public enum TokenType
        {
            None,
            @foreach(var rule in Model.RuleSet.TokenRules)
            {<text>        @rule.Name.Replace("#", ""),
    </text>}
        }

        public enum RuleType
        {
            None,
            @foreach(var rule in Model.RuleSet.Where(r => !r.TempRule))
            {<text>        @rule.Name.Replace("#", "_"), // @rule.ToString(true)
    </text>}
        }


        public boolean StopAtFirstError;

        class ParserContext
        {
            public final ITokenScanner TokenScanner;
            public final ITokenMatcher TokenMatcher;
            public final IAstBuilder Builder;
            public final Queue<Token> TokenQueue;
            public final List<ParserException> Errors;


            ParserContext(ITokenScanner tokenScanner, ITokenMatcher tokenMatcher, IAstBuilder builder, Queue<Token> tokenQueue, List<ParserException> errors) {
                TokenScanner = tokenScanner;
                TokenMatcher = tokenMatcher;
                Builder = builder;
                TokenQueue = tokenQueue;
                Errors = errors;
            }
        }

        public Object Parse(ITokenScanner tokenScanner)
        {
            return Parse(tokenScanner, new TokenMatcher(), new AstBuilder());
        }

        public Object Parse(ITokenScanner tokenScanner, ITokenMatcher tokenMatcher, IAstBuilder astBuilder)
        {
            ParserContext context = new ParserContext(
                tokenScanner,
                tokenMatcher,
                astBuilder,
                new LinkedList<Token>(),
                new ArrayList<ParserException>()
            );

            StartRule(context, RuleType.@Model.RuleSet.StartRule.Name);
            int state = 0;
            Token token;
            do
            {
                token = ReadToken(context);
                state = MatchToken(state, token, context);
            } while(!token.IsEOF());

            EndRule(context, RuleType.@Model.RuleSet.StartRule.Name);

            if (context.Errors.size() > 0)
            {
                throw new ParserException.CompositeParserException(context.Errors);
            }

            return GetResult(context);
        }

    private void AddError(ParserContext context, ParserException error) {
        context.Errors.add(error);
        if (context.Errors.size() > 10)
            throw new ParserException.CompositeParserException(context.Errors);
    }

    private <T> T HandleAstError(ParserContext context, final Func<T> action) {
        return HandleExternalError(context, new Func<T>() {
            public T call() {
                return action.call();
            }
        }, null);
    }

    private <T> T HandleExternalError(ParserContext context, Func<T> action, T defaultValue) {
        if (StopAtFirstError) {
            return action.call();
        }

        try {
            return action.call();
        } catch (ParserException.CompositeParserException compositeParserException) {
            for (ParserException error : compositeParserException.Errors) {
                AddError(context, error);
            }
        } catch (ParserException error) {
            AddError(context, error);
        }
        return defaultValue;
    }

    void Build(final ParserContext context, final Token token) {
        HandleAstError(context, new Func<Void>() {
            public Void call() {
                context.Builder.Build(token);
                return null;
            }
        });
    }

    void StartRule(final ParserContext context, final RuleType ruleType) {
        HandleAstError(context, new Func<Void>() {
            public Void call() {
                context.Builder.StartRule(ruleType);
                return null;
            }
        });
    }

    void EndRule(final ParserContext context, final RuleType ruleType) {
        HandleAstError(context, new Func<Void>() {
            public Void call() {
                context.Builder.EndRule(ruleType);
                return null;
            }
        });
    }

        Object GetResult(ParserContext context)
        {
            return context.Builder.GetResult();
        }

        Token ReadToken(ParserContext context)
        {
            return context.TokenQueue.size() > 0 ? context.TokenQueue.remove() : context.TokenScanner.Read();
        }

        @foreach(var rule in Model.RuleSet.TokenRules)
        {<text>
        boolean Match_@(rule.Name.Replace("#", ""))(final ParserContext context, final Token token) {
            return HandleExternalError(context, new Func<Boolean>() {
                public Boolean call() {
                    return context.TokenMatcher.Match_@(rule.Name.Replace("#", ""))(token);
                }
            }, false);
        }</text>
        }

        int MatchToken(int state, Token token, ParserContext context)
        {
            int newState;
            switch(state)
            {
            @foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
            {
                @:case @state.Id:
                    @:newState = MatchTokenAt_@(state.Id)(token, context);
                    @:break;
            }
                default:
                    throw new IllegalStateException("Unknown state: " + state);
            }
            return newState;
        }

    @foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
    {
        <text>
        // @Raw(state.Comment)
        int MatchTokenAt_@(state.Id)(Token token, ParserContext context)
        {
            @foreach(var transition in state.Transitions)
            {
            @:if (@MatchToken(transition.TokenType))
            @:{
                if (transition.LookAheadHint != null)
                {
                @:if (LookAhead_@(transition.LookAheadHint.Id)(context, token))
                @:{
                }
                foreach(var production in transition.Productions)
                {
                    @CallProduction(production)
                }
                @:return @transition.TargetState;
                if (transition.LookAheadHint != null)
                {
                @:}
                }
            @:}
            }
            @HandleParserError(state.Transitions.Select(t => "#" + t.TokenType.ToString()).Distinct(), state)
        }
        </text>
    }

    @foreach(var lookAheadHint in Model.RuleSet.LookAheadHints)
    {
        <text>
        boolean LookAhead_@(lookAheadHint.Id)(ParserContext context, Token currentToken)
        {
            currentToken.Detach();
            Token token;
            Queue<Token> queue = new ArrayDeque<Token>();
            boolean match = false;
            do
            {
                token = ReadToken(context);
                token.Detach();
                queue.add(token);

                if (false
                @foreach(var tokenType in lookAheadHint.ExpectedTokens)
                {
                    @:|| @MatchToken(tokenType)
                }
                )
                {
                    match = true;
                    break;
                }
            } while (false
            @foreach(var tokenType in lookAheadHint.Skip)
            {
                @:|| @MatchToken(tokenType)
            }
            );
            for (Token t : queue) {
                context.TokenQueue.add(t);
            }
            return match;
        }
        </text>
    }

    public interface IAstBuilder
    {
        void Build(Token token);
        void StartRule(RuleType ruleType);
        void EndRule(RuleType ruleType);
        Object GetResult();
    }

    public interface ITokenScanner
    {
        Token Read();
    }

    public interface ITokenMatcher
    {
        @foreach(var rule in Model.RuleSet.TokenRules)
        {
        @:boolean Match_@(rule.Name.Replace("#", ""))(Token token);
        }
    }

}
